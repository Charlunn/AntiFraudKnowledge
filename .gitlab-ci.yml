# .gitlab-ci.yml

# 定义 CI/CD 的各个阶段
stages:
  - build
  # - test # 如果需要测试阶段，可以添加
  - deploy

# 定义一些全局变量，方便复用
variables:
  DOCKER_DRIVER: overlay2 # 推荐的 Docker 存储驱动
  # DOCKER_TLS_CERTDIR: "/certs" # 移除全局的，将在需要 DinD 的 job 中设置为空 ""
  # 定义 Compose 项目名称，避免不同项目冲突，默认为目录名
  COMPOSE_PROJECT_NAME: myapp_${CI_COMMIT_REF_SLUG} # 使用分支名作为后缀，防止并发部署冲突

# ==================================
#  Backend 服务 (Django)
# ==================================
build_backend:
  stage: build
  image: docker:latest # 使用包含 Docker CLI 和 Compose 的镜像
  services: # <--- 添加 services 块以启动 DinD
    - name: docker:dind
      alias: docker # 设置服务别名，DOCKER_HOST 可以使用它
  variables: # <--- 修改/添加 DinD 所需的变量
    # 告诉 Docker CLI 连接到 DinD 服务容器
    DOCKER_HOST: tcp://docker:2375
    # 禁用 TLS，因为标准 DinD 服务默认不使用 TLS
    DOCKER_TLS_CERTDIR: ""
    # DOCKER_DRIVER 已在全局定义
  before_script: # <--- 添加 before_script
    # 1. 移除 docker-compose.yml 中过时的 'version:' 属性 (建议直接在代码库中修改)
    - sed -i '/^version:/d' docker-compose.yml
    # 2. 等待 Docker-in-Docker 服务完全启动并准备就绪
    - until docker info; do echo "Waiting for Docker daemon..."; sleep 1; done
    # 登录 Docker Registry (如果需要推送到私有或 GitLab Registry, 取消注释并配置相关 CI/CD 变量)
    # - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - echo "Building backend service..."
    # 使用 docker compose build 构建，它会读取 docker-compose.yml 中的 build 配置
    - docker compose build backend # 确认使用无连字符命令
    # 如果需要推送到 Registry (取消注释并替换 <image_name_backend>)
    # - docker tag <image_name_backend> $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
    # - docker push $CI_REGISTRY_IMAGE/backend:$CI_COMMIT_SHA
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"' # 只在 main 分支运行
      changes:
        - backend/**/* # 当 backend 目录下的任何文件改变时触发
        - docker-compose.yml # 当 docker-compose 文件改变时也触发（可能影响构建）
        - backend/Dockerfile.backend # 当 Dockerfile 改变时触发

deploy_backend:
  stage: deploy
  # needs: [build_backend] # 如果 build 和 deploy 在不同 Runner 或需要明确依赖关系
  # 注意：此 Job 通过 SSH 在目标服务器上执行 Docker 命令，因此不需要 DinD 服务
  before_script:
    # 设置 SSH 环境，让 Runner 可以免密登录部署服务器
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )' # 确保 ssh-agent 已安装 (Debian/Ubuntu)
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - # 添加私钥
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    # 将服务器的公钥添加到 known_hosts，避免首次连接的交互提示
    - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "Deploying backend service to $DEPLOY_SERVER_IP..."
    - > # 使用多行命令，更清晰
      ssh ${DEPLOY_USER}@${DEPLOY_SERVER_IP} "
        cd ${DEPLOY_PATH} && \\
        echo 'Pulling latest code...' && \\
        git pull origin main && \\
        echo 'Pulling latest backend image (if using registry)...' && \\
        # 如果你推送了镜像到 Registry，需要先 pull (取消注释)
        # docker compose pull backend && \\
        echo 'Building backend image locally on target server...' && \\
        # 注意：确保 $DEPLOY_SERVER_IP 上安装了 Docker Compose v2 (docker compose)
        # 如果目标服务器是 v1，请将下面的命令改为 docker-compose (带连字符)
        docker compose build backend && \\
        echo 'Starting backend service...' && \\
        docker compose up -d --no-deps backend && \\
        echo 'Backend deployment complete.'
      "
  environment: # 定义部署环境，方便在 GitLab UI 中查看
    name: production/backend
    url: http://your-backend-url.com # 替换成你的后端访问地址
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - backend/**/*
        - docker-compose.yml
        - backend/Dockerfile.backend
      when: on_success # 仅在 build 成功后执行 (如果定义了 needs) 或独立执行

# ==================================
#  Frontend 服务
# ==================================
build_frontend:
  stage: build
  image: docker:latest # 使用包含 Docker CLI 和 Compose 的镜像
  services: # <--- 添加 services 块以启动 DinD
    - name: docker:dind
      alias: docker
  variables: # <--- 修改/添加 DinD 所需的变量
    DOCKER_HOST: tcp://docker:2375
    DOCKER_TLS_CERTDIR: ""
    # DOCKER_DRIVER 已在全局定义
  before_script: # <--- 添加 before_script
    # 1. 移除 docker-compose.yml 中过时的 'version:' 属性 (建议直接在代码库中修改)
    - sed -i '/^version:/d' docker-compose.yml
    # 2. 等待 Docker-in-Docker 服务完全启动并准备就绪
    - until docker info; do echo "Waiting for Docker daemon..."; sleep 1; done
    # 登录 Docker Registry (如果需要)
    # - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
  script:
    - echo "Building frontend service..."
    - docker compose build frontend # 确认使用无连字符命令
    # 如果需要推送到 Registry (取消注释并替换 <image_name_frontend>)
    # - docker tag <image_name_frontend> $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
    # - docker push $CI_REGISTRY_IMAGE/frontend:$CI_COMMIT_SHA
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - frontend/**/* # 当 frontend 目录下的任何文件改变时触发
        - docker-compose.yml
        - frontend/Dockerfile.frontend

deploy_frontend:
  stage: deploy
  # needs: [build_frontend]
  # 注意：此 Job 通过 SSH 在目标服务器上执行 Docker 命令，因此不需要 DinD 服务
  before_script: # 和 deploy_backend 类似，设置 SSH
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "Deploying frontend service to $DEPLOY_SERVER_IP..."
    - >
      ssh ${DEPLOY_USER}@${DEPLOY_SERVER_IP} "
        cd ${DEPLOY_PATH} && \\
        echo 'Pulling latest code...' && \\
        git pull origin main && \\
        echo 'Pulling latest frontend image (if using registry)...' && \\
        # docker compose pull frontend && \\
        echo 'Building frontend image locally on target server...' && \\
        # 注意：确保 $DEPLOY_SERVER_IP 上安装了 Docker Compose v2 (docker compose)
        # 如果目标服务器是 v1，请将下面的命令改为 docker-compose (带连字符)
        docker compose build frontend && \\
        echo 'Starting frontend service...' && \\
        docker compose up -d --no-deps frontend && \\
        echo 'Frontend deployment complete.'
      "
  environment:
    name: production/frontend
    url: http://your-frontend-url.com # 替换成你的前端访问地址
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - frontend/**/*
        - docker-compose.yml
        - frontend/Dockerfile.frontend
      when: on_success

# ==================================
#  数据库服务 (MySQL, Neo4j) - 通常不需要构建
# ==================================
deploy_infrastructure:
  stage: deploy
  # 注意：此 Job 通过 SSH 在目标服务器上执行 Docker 命令，因此不需要 DinD 服务
  before_script: # 和其他 deploy job 类似
    - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add -
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
    - ssh-keyscan -H $DEPLOY_SERVER_IP >> ~/.ssh/known_hosts
    - chmod 644 ~/.ssh/known_hosts
  script:
    - echo "Applying potential infrastructure changes from docker-compose.yml on $DEPLOY_SERVER_IP..."
    - >
      ssh ${DEPLOY_USER}@${DEPLOY_SERVER_IP} "
        cd ${DEPLOY_PATH} && \\
        echo 'Pulling latest code (including docker-compose.yml)...' && \\
        git pull origin main && \\
        echo 'Pulling latest mysql and neo4j images...' && \\
        # 注意：确保 $DEPLOY_SERVER_IP 上安装了 Docker Compose v2 (docker compose)
        # 如果目标服务器是 v1，请将下面的命令改为 docker-compose (带连字符)
        docker compose pull mysql && \\
        docker compose pull neo4j && \\
        echo 'Applying docker compose changes (if any)...' && \\
        docker compose up -d && \\
        echo 'Infrastructure update complete.'
      "
  environment:
    name: production/infrastructure
  rules:
    # 这个 Job 只在 docker-compose.yml 变化时运行
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - docker-compose.yml
      when: on_success