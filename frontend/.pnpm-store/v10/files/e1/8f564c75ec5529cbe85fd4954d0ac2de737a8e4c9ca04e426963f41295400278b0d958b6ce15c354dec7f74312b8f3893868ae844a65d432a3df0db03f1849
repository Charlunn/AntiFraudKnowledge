import { type ECSSRClientEventParams, type ECSSREvent } from 'echarts/ssr/client/index';
import type { InitOptions, Option, Theme } from '../types.js';
import { nextTick, type PropType } from 'vue';
type ECSSRHandler = (params: ECSSRClientEventParams) => string | undefined;
declare const _default: import("vue").DefineComponent<import("vue").ExtractPropTypes<{
    option: PropType<Option>;
    theme: {
        type: PropType<Theme>;
    };
    initOptions: PropType<InitOptions>;
}>, {
    root: import("vue").Ref<({
        $: import("vue").ComponentInternalInstance;
        $data: {};
        $props: {
            readonly option?: Option | undefined;
            readonly theme?: Theme | undefined;
            readonly initOptions?: InitOptions | undefined;
            readonly onError?: ((error: unknown) => any) | undefined;
        } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        } & {
            root: ({
                $: import("vue").ComponentInternalInstance;
                $data: {};
                $props: {
                    readonly option?: Option | undefined;
                    readonly initOptions?: InitOptions | undefined;
                    readonly theme?: Theme | undefined;
                } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
                $attrs: {
                    [x: string]: unknown;
                };
                $refs: {
                    [x: string]: unknown;
                };
                $slots: Readonly<{
                    [name: string]: import("vue").Slot<any> | undefined;
                }>;
                $root: import("vue").ComponentPublicInstance | null;
                $parent: import("vue").ComponentPublicInstance | null;
                $host: Element | null;
                $emit: (event: string, ...args: any[]) => void;
                $el: HTMLDivElement;
                $options: import("vue").ComponentOptionsBase<Readonly<{
                    option?: Option;
                    initOptions?: InitOptions;
                    theme?: Theme;
                }> & Readonly<{}>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
                    beforeCreate?: (() => void) | (() => void)[];
                    created?: (() => void) | (() => void)[];
                    beforeMount?: (() => void) | (() => void)[];
                    mounted?: (() => void) | (() => void)[];
                    beforeUpdate?: (() => void) | (() => void)[];
                    updated?: (() => void) | (() => void)[];
                    activated?: (() => void) | (() => void)[];
                    deactivated?: (() => void) | (() => void)[];
                    beforeDestroy?: (() => void) | (() => void)[];
                    beforeUnmount?: (() => void) | (() => void)[];
                    destroyed?: (() => void) | (() => void)[];
                    unmounted?: (() => void) | (() => void)[];
                    renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
                };
                $forceUpdate: () => void;
                $nextTick: typeof nextTick;
                $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
            } & Readonly<{}> & Omit<Readonly<{
                option?: Option;
                initOptions?: InitOptions;
                theme?: Theme;
            }> & Readonly<{}>, never> & import("vue").ShallowUnwrapRef<{}> & {} & import("vue").ComponentCustomProperties & {} & {
                $slots: {
                    fallback: any;
                };
            } & {
                $: import("vue").ComponentInternalInstance;
                $data: {};
                $props: Partial<{}> & Omit<{}, never>;
                $attrs: {
                    [x: string]: unknown;
                };
                $refs: {
                    [x: string]: unknown;
                };
                $slots: Readonly<{
                    fallback: import("vue").Slot<{
                        error: unknown;
                    }>;
                }>;
                $root: import("vue").ComponentPublicInstance | null;
                $parent: import("vue").ComponentPublicInstance | null;
                $host: Element | null;
                $emit: (event: string, ...args: any[]) => void;
                $el: any;
                $options: import("vue").ComponentOptionsBase<{}, {
                    refresh: () => Promise<void>;
                }, {}, {}, {}, {}, {}, {}, string, {}, {}, string, import("vue").SlotsType<{
                    fallback: {
                        error: unknown;
                    };
                }>, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
                    beforeCreate?: (() => void) | (() => void)[];
                    created?: (() => void) | (() => void)[];
                    beforeMount?: (() => void) | (() => void)[];
                    mounted?: (() => void) | (() => void)[];
                    beforeUpdate?: (() => void) | (() => void)[];
                    updated?: (() => void) | (() => void)[];
                    activated?: (() => void) | (() => void)[];
                    deactivated?: (() => void) | (() => void)[];
                    beforeDestroy?: (() => void) | (() => void)[];
                    beforeUnmount?: (() => void) | (() => void)[];
                    destroyed?: (() => void) | (() => void)[];
                    unmounted?: (() => void) | (() => void)[];
                    renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
                };
                $forceUpdate: () => void;
                $nextTick: typeof nextTick;
                $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
            } & Readonly<{}> & Omit<{}, "refresh"> & import("vue").ShallowUnwrapRef<{
                refresh: () => Promise<void>;
            }>) | null;
        };
        $slots: Readonly<{
            [name: string]: import("vue").Slot<any> | undefined;
        }>;
        $root: import("vue").ComponentPublicInstance | null;
        $parent: import("vue").ComponentPublicInstance | null;
        $host: Element | null;
        $emit: (event: "error", error: unknown) => void;
        $el: HTMLDivElement;
        $options: import("vue").ComponentOptionsBase<Readonly<{
            option?: Option;
            theme?: Theme;
            initOptions?: InitOptions;
        }> & Readonly<{
            onError?: ((error: unknown) => any) | undefined;
        }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {} & {
            error: (error: unknown) => any;
        }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
    } & Readonly<{}> & Omit<Readonly<{
        option?: Option;
        theme?: Theme;
        initOptions?: InitOptions;
    }> & Readonly<{
        onError?: ((error: unknown) => any) | undefined;
    }>, never> & import("vue").ShallowUnwrapRef<{}> & {} & import("vue").ComponentCustomProperties & {} & {
        $slots: {
            fallback?: ((props: {}) => any) | undefined;
        };
    }) | null, ({
        $: import("vue").ComponentInternalInstance;
        $data: {};
        $props: {
            readonly option?: Option | undefined;
            readonly theme?: Theme | undefined;
            readonly initOptions?: InitOptions | undefined;
            readonly onError?: ((error: unknown) => any) | undefined;
        } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        } & {
            root: ({
                $: import("vue").ComponentInternalInstance;
                $data: {};
                $props: {
                    readonly option?: Option | undefined;
                    readonly initOptions?: InitOptions | undefined;
                    readonly theme?: Theme | undefined;
                } & import("vue").VNodeProps & import("vue").AllowedComponentProps & import("vue").ComponentCustomProps;
                $attrs: {
                    [x: string]: unknown;
                };
                $refs: {
                    [x: string]: unknown;
                };
                $slots: Readonly<{
                    [name: string]: import("vue").Slot<any> | undefined;
                }>;
                $root: import("vue").ComponentPublicInstance | null;
                $parent: import("vue").ComponentPublicInstance | null;
                $host: Element | null;
                $emit: (event: string, ...args: any[]) => void;
                $el: HTMLDivElement;
                $options: import("vue").ComponentOptionsBase<Readonly<{
                    option?: Option;
                    initOptions?: InitOptions;
                    theme?: Theme;
                }> & Readonly<{}>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
                    beforeCreate?: (() => void) | (() => void)[];
                    created?: (() => void) | (() => void)[];
                    beforeMount?: (() => void) | (() => void)[];
                    mounted?: (() => void) | (() => void)[];
                    beforeUpdate?: (() => void) | (() => void)[];
                    updated?: (() => void) | (() => void)[];
                    activated?: (() => void) | (() => void)[];
                    deactivated?: (() => void) | (() => void)[];
                    beforeDestroy?: (() => void) | (() => void)[];
                    beforeUnmount?: (() => void) | (() => void)[];
                    destroyed?: (() => void) | (() => void)[];
                    unmounted?: (() => void) | (() => void)[];
                    renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
                };
                $forceUpdate: () => void;
                $nextTick: typeof nextTick;
                $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
            } & Readonly<{}> & Omit<Readonly<{
                option?: Option;
                initOptions?: InitOptions;
                theme?: Theme;
            }> & Readonly<{}>, never> & import("vue").ShallowUnwrapRef<{}> & {} & import("vue").ComponentCustomProperties & {} & {
                $slots: {
                    fallback: any;
                };
            } & {
                $: import("vue").ComponentInternalInstance;
                $data: {};
                $props: Partial<{}> & Omit<{}, never>;
                $attrs: {
                    [x: string]: unknown;
                };
                $refs: {
                    [x: string]: unknown;
                };
                $slots: Readonly<{
                    fallback: import("vue").Slot<{
                        error: unknown;
                    }>;
                }>;
                $root: import("vue").ComponentPublicInstance | null;
                $parent: import("vue").ComponentPublicInstance | null;
                $host: Element | null;
                $emit: (event: string, ...args: any[]) => void;
                $el: any;
                $options: import("vue").ComponentOptionsBase<{}, {
                    refresh: () => Promise<void>;
                }, {}, {}, {}, {}, {}, {}, string, {}, {}, string, import("vue").SlotsType<{
                    fallback: {
                        error: unknown;
                    };
                }>, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
                    beforeCreate?: (() => void) | (() => void)[];
                    created?: (() => void) | (() => void)[];
                    beforeMount?: (() => void) | (() => void)[];
                    mounted?: (() => void) | (() => void)[];
                    beforeUpdate?: (() => void) | (() => void)[];
                    updated?: (() => void) | (() => void)[];
                    activated?: (() => void) | (() => void)[];
                    deactivated?: (() => void) | (() => void)[];
                    beforeDestroy?: (() => void) | (() => void)[];
                    beforeUnmount?: (() => void) | (() => void)[];
                    destroyed?: (() => void) | (() => void)[];
                    unmounted?: (() => void) | (() => void)[];
                    renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
                    errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
                };
                $forceUpdate: () => void;
                $nextTick: typeof nextTick;
                $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
            } & Readonly<{}> & Omit<{}, "refresh"> & import("vue").ShallowUnwrapRef<{
                refresh: () => Promise<void>;
            }>) | null;
        };
        $slots: Readonly<{
            [name: string]: import("vue").Slot<any> | undefined;
        }>;
        $root: import("vue").ComponentPublicInstance | null;
        $parent: import("vue").ComponentPublicInstance | null;
        $host: Element | null;
        $emit: (event: "error", error: unknown) => void;
        $el: HTMLDivElement;
        $options: import("vue").ComponentOptionsBase<Readonly<{
            option?: Option;
            theme?: Theme;
            initOptions?: InitOptions;
        }> & Readonly<{
            onError?: ((error: unknown) => any) | undefined;
        }>, {}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {} & {
            error: (error: unknown) => any;
        }, string, {}, {}, string, {}, import("vue").GlobalComponents, import("vue").GlobalDirectives, string, import("vue").ComponentProvideOptions> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            renderTriggered?: ((e: import("vue").DebuggerEvent) => void) | ((e: import("vue").DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void) | ((err: unknown, instance: import("vue").ComponentPublicInstance | null, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof nextTick;
        $watch<T extends string | ((...args: any) => any)>(source: T, cb: T extends (...args: any) => infer R ? (...args: [R, R, import("@vue/reactivity").OnCleanup]) => any : (...args: [any, any, import("@vue/reactivity").OnCleanup]) => any, options?: import("vue").WatchOptions): import("vue").WatchStopHandle;
    } & Readonly<{}> & Omit<Readonly<{
        option?: Option;
        theme?: Theme;
        initOptions?: InitOptions;
    }> & Readonly<{
        onError?: ((error: unknown) => any) | undefined;
    }>, never> & import("vue").ShallowUnwrapRef<{}> & {} & import("vue").ComponentCustomProperties & {} & {
        $slots: {
            fallback?: ((props: {}) => any) | undefined;
        };
    }) | null>;
}, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, Record<ECSSREvent, ECSSRHandler>, string, import("vue").PublicProps, Readonly<import("vue").ExtractPropTypes<{
    option: PropType<Option>;
    theme: {
        type: PropType<Theme>;
    };
    initOptions: PropType<InitOptions>;
}>> & Readonly<{
    onClick?: ((params: ECSSRClientEventParams) => any) | undefined;
    onMouseout?: ((params: ECSSRClientEventParams) => any) | undefined;
    onMouseover?: ((params: ECSSRClientEventParams) => any) | undefined;
}>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
export default _default;
declare global {
    const __VLS_intrinsicElements: __VLS_IntrinsicElements;
    const __VLS_directiveBindingRestFields: {
        instance: null;
        oldValue: null;
        modifiers: any;
        dir: any;
    };
    const __VLS_unref: typeof import('vue').unref;
    const __VLS_placeholder: any;
    const __VLS_nativeElements: {
        a: HTMLAnchorElement;
        abbr: HTMLElement;
        address: HTMLElement;
        area: HTMLAreaElement;
        article: HTMLElement;
        aside: HTMLElement;
        audio: HTMLAudioElement;
        b: HTMLElement;
        base: HTMLBaseElement;
        bdi: HTMLElement;
        bdo: HTMLElement;
        blockquote: HTMLQuoteElement;
        body: HTMLBodyElement;
        br: HTMLBRElement;
        button: HTMLButtonElement;
        canvas: HTMLCanvasElement;
        caption: HTMLTableCaptionElement;
        cite: HTMLElement;
        code: HTMLElement;
        col: HTMLTableColElement;
        colgroup: HTMLTableColElement;
        data: HTMLDataElement;
        datalist: HTMLDataListElement;
        dd: HTMLElement;
        del: HTMLModElement;
        details: HTMLDetailsElement;
        dfn: HTMLElement;
        dialog: HTMLDialogElement;
        div: HTMLDivElement;
        dl: HTMLDListElement;
        dt: HTMLElement;
        em: HTMLElement;
        embed: HTMLEmbedElement;
        fieldset: HTMLFieldSetElement;
        figcaption: HTMLElement;
        figure: HTMLElement;
        footer: HTMLElement;
        form: HTMLFormElement;
        h1: HTMLHeadingElement;
        h2: HTMLHeadingElement;
        h3: HTMLHeadingElement;
        h4: HTMLHeadingElement;
        h5: HTMLHeadingElement;
        h6: HTMLHeadingElement;
        head: HTMLHeadElement;
        header: HTMLElement;
        hgroup: HTMLElement;
        hr: HTMLHRElement;
        html: HTMLHtmlElement;
        i: HTMLElement;
        iframe: HTMLIFrameElement;
        img: HTMLImageElement;
        input: HTMLInputElement;
        ins: HTMLModElement;
        kbd: HTMLElement;
        label: HTMLLabelElement;
        legend: HTMLLegendElement;
        li: HTMLLIElement;
        link: HTMLLinkElement;
        main: HTMLElement;
        map: HTMLMapElement;
        mark: HTMLElement;
        menu: HTMLMenuElement;
        meta: HTMLMetaElement;
        meter: HTMLMeterElement;
        nav: HTMLElement;
        noscript: HTMLElement;
        object: HTMLObjectElement;
        ol: HTMLOListElement;
        optgroup: HTMLOptGroupElement;
        option: HTMLOptionElement;
        output: HTMLOutputElement;
        p: HTMLParagraphElement;
        picture: HTMLPictureElement;
        pre: HTMLPreElement;
        progress: HTMLProgressElement;
        q: HTMLQuoteElement;
        rp: HTMLElement;
        rt: HTMLElement;
        ruby: HTMLElement;
        s: HTMLElement;
        samp: HTMLElement;
        script: HTMLScriptElement;
        search: HTMLElement;
        section: HTMLElement;
        select: HTMLSelectElement;
        slot: HTMLSlotElement;
        small: HTMLElement;
        source: HTMLSourceElement;
        span: HTMLSpanElement;
        strong: HTMLElement;
        style: HTMLStyleElement;
        sub: HTMLElement;
        summary: HTMLElement;
        sup: HTMLElement;
        table: HTMLTableElement;
        tbody: HTMLTableSectionElement;
        td: HTMLTableCellElement;
        template: HTMLTemplateElement;
        textarea: HTMLTextAreaElement;
        tfoot: HTMLTableSectionElement;
        th: HTMLTableCellElement;
        thead: HTMLTableSectionElement;
        time: HTMLTimeElement;
        title: HTMLTitleElement;
        tr: HTMLTableRowElement;
        track: HTMLTrackElement;
        u: HTMLElement;
        ul: HTMLUListElement;
        var: HTMLElement;
        video: HTMLVideoElement;
        wbr: HTMLElement;
        animate: SVGAnimateElement;
        animateMotion: SVGAnimateMotionElement;
        animateTransform: SVGAnimateTransformElement;
        circle: SVGCircleElement;
        clipPath: SVGClipPathElement;
        defs: SVGDefsElement;
        desc: SVGDescElement;
        ellipse: SVGEllipseElement;
        feBlend: SVGFEBlendElement;
        feColorMatrix: SVGFEColorMatrixElement;
        feComponentTransfer: SVGFEComponentTransferElement;
        feComposite: SVGFECompositeElement;
        feConvolveMatrix: SVGFEConvolveMatrixElement;
        feDiffuseLighting: SVGFEDiffuseLightingElement;
        feDisplacementMap: SVGFEDisplacementMapElement;
        feDistantLight: SVGFEDistantLightElement;
        feDropShadow: SVGFEDropShadowElement;
        feFlood: SVGFEFloodElement;
        feFuncA: SVGFEFuncAElement;
        feFuncB: SVGFEFuncBElement;
        feFuncG: SVGFEFuncGElement;
        feFuncR: SVGFEFuncRElement;
        feGaussianBlur: SVGFEGaussianBlurElement;
        feImage: SVGFEImageElement;
        feMerge: SVGFEMergeElement;
        feMergeNode: SVGFEMergeNodeElement;
        feMorphology: SVGFEMorphologyElement;
        feOffset: SVGFEOffsetElement;
        fePointLight: SVGFEPointLightElement;
        feSpecularLighting: SVGFESpecularLightingElement;
        feSpotLight: SVGFESpotLightElement;
        feTile: SVGFETileElement;
        feTurbulence: SVGFETurbulenceElement;
        filter: SVGFilterElement;
        foreignObject: SVGForeignObjectElement;
        g: SVGGElement;
        image: SVGImageElement;
        line: SVGLineElement;
        linearGradient: SVGLinearGradientElement;
        marker: SVGMarkerElement;
        mask: SVGMaskElement;
        metadata: SVGMetadataElement;
        mpath: SVGMPathElement;
        path: SVGPathElement;
        pattern: SVGPatternElement;
        polygon: SVGPolygonElement;
        polyline: SVGPolylineElement;
        radialGradient: SVGRadialGradientElement;
        rect: SVGRectElement;
        set: SVGSetElement;
        stop: SVGStopElement;
        svg: SVGSVGElement;
        switch: SVGSwitchElement;
        symbol: SVGSymbolElement;
        text: SVGTextElement;
        textPath: SVGTextPathElement;
        tspan: SVGTSpanElement;
        use: SVGUseElement;
        view: SVGViewElement;
    };
    type __VLS_IntrinsicElements = import('vue/jsx-runtime').JSX.IntrinsicElements;
    type __VLS_Element = import('vue/jsx-runtime').JSX.Element;
    type __VLS_GlobalComponents = import('vue').GlobalComponents;
    type __VLS_GlobalDirectives = import('vue').GlobalDirectives;
    type __VLS_IsAny<T> = 0 extends 1 & T ? true : false;
    type __VLS_PickNotAny<A, B> = __VLS_IsAny<A> extends true ? B : A;
    type __VLS_unknownDirective = (arg1: unknown, arg2: unknown, arg3: unknown, arg4: unknown) => void;
    type __VLS_WithComponent<N0 extends string, LocalComponents, Self, N1 extends string, N2 extends string, N3 extends string> = N1 extends keyof LocalComponents ? N1 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N1];
    } : N2 extends keyof LocalComponents ? N2 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N2];
    } : N3 extends keyof LocalComponents ? N3 extends N0 ? Pick<LocalComponents, N0 extends keyof LocalComponents ? N0 : never> : {
        [K in N0]: LocalComponents[N3];
    } : Self extends object ? {
        [K in N0]: Self;
    } : N1 extends keyof __VLS_GlobalComponents ? N1 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N1];
    } : N2 extends keyof __VLS_GlobalComponents ? N2 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N2];
    } : N3 extends keyof __VLS_GlobalComponents ? N3 extends N0 ? Pick<__VLS_GlobalComponents, N0 extends keyof __VLS_GlobalComponents ? N0 : never> : {
        [K in N0]: __VLS_GlobalComponents[N3];
    } : {
        [K in N0]: unknown;
    };
    type __VLS_FunctionalComponentProps<T, K> = '__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends {
        __ctx?: {
            props?: infer P;
        };
    } ? NonNullable<P> : never : T extends (props: infer P, ...args: any) => any ? P : {};
    type __VLS_IsFunction<T, K> = K extends keyof T ? __VLS_IsAny<T[K]> extends false ? unknown extends T[K] ? false : true : false : false;
    type __VLS_NormalizeComponentEvent<Props, Events, onEvent extends keyof Props, Event extends keyof Events, CamelizedEvent extends keyof Events> = (__VLS_IsFunction<Props, onEvent> extends true ? Props : __VLS_IsFunction<Events, Event> extends true ? {
        [K in onEvent]?: Events[Event];
    } : __VLS_IsFunction<Events, CamelizedEvent> extends true ? {
        [K in onEvent]?: Events[CamelizedEvent];
    } : Props) & Record<string, unknown>;
    type __VLS_UnionToIntersection<U> = (U extends unknown ? (arg: U) => unknown : never) extends ((arg: infer P) => unknown) ? P : never;
    type __VLS_OverloadUnionInner<T, U = unknown> = U & T extends (...args: infer A) => infer R ? U extends T ? never : __VLS_OverloadUnionInner<T, Pick<T, keyof T> & U & ((...args: A) => R)> | ((...args: A) => R) : never;
    type __VLS_OverloadUnion<T> = Exclude<__VLS_OverloadUnionInner<(() => never) & T>, T extends () => never ? never : () => never>;
    type __VLS_ConstructorOverloads<T> = __VLS_OverloadUnion<T> extends infer F ? F extends (event: infer E, ...args: infer A) => any ? {
        [K in E & string]: (...args: A) => void;
    } : never : never;
    type __VLS_NormalizeEmits<T> = __VLS_PrettifyGlobal<__VLS_UnionToIntersection<__VLS_ConstructorOverloads<T> & {
        [K in keyof T]: T[K] extends any[] ? {
            (...args: T[K]): void;
        } : never;
    }>>;
    type __VLS_PrettifyGlobal<T> = {
        [K in keyof T]: T[K];
    } & {};
    type __VLS_PickFunctionalComponentCtx<T, K> = NonNullable<__VLS_PickNotAny<'__ctx' extends keyof __VLS_PickNotAny<K, {}> ? K extends {
        __ctx?: infer Ctx;
    } ? Ctx : never : any, T extends (props: any, ctx: infer Ctx) => any ? Ctx : any>>;
    type __VLS_OmitStringIndex<T> = {
        [K in keyof T as string extends K ? never : K]: T[K];
    };
    type __VLS_UseTemplateRef<T> = Readonly<import('vue').ShallowRef<T | null>>;
    function __VLS_getVForSourceType(source: number): [number, number][];
    function __VLS_getVForSourceType(source: string): [string, number][];
    function __VLS_getVForSourceType<T extends any[]>(source: T): [
        item: T[number],
        index: number
    ][];
    function __VLS_getVForSourceType<T extends {
        [Symbol.iterator](): Iterator<any>;
    }>(source: T): [
        item: T extends {
            [Symbol.iterator](): Iterator<infer T1>;
        } ? T1 : never,
        index: number
    ][];
    function __VLS_getVForSourceType<T extends number | {
        [Symbol.iterator](): Iterator<any>;
    }>(source: T): [
        item: number | (Exclude<T, number> extends {
            [Symbol.iterator](): Iterator<infer T1>;
        } ? T1 : never),
        index: number
    ][];
    function __VLS_getVForSourceType<T>(source: T): [
        item: T[keyof T],
        key: keyof T,
        index: number
    ][];
    function __VLS_getSlotParams<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>;
    function __VLS_getSlotParam<T>(slot: T): Parameters<__VLS_PickNotAny<NonNullable<T>, (...args: any[]) => any>>[0];
    function __VLS_asFunctionalDirective<T>(dir: T): T extends import('vue').ObjectDirective ? NonNullable<T['created' | 'beforeMount' | 'mounted' | 'beforeUpdate' | 'updated' | 'beforeUnmount' | 'unmounted']> : T extends (...args: any) => any ? T : __VLS_unknownDirective;
    function __VLS_withScope<T, K>(ctx: T, scope: K): ctx is T & K;
    function __VLS_makeOptional<T>(t: T): {
        [K in keyof T]?: T[K];
    };
    function __VLS_asFunctionalComponent<T, K = T extends new (...args: any) => any ? InstanceType<T> : unknown>(t: T, instance?: K): T extends new (...args: any) => any ? (props: (K extends {
        $props: infer Props;
    } ? Props : any) & Record<string, unknown>, ctx?: any) => __VLS_Element & {
        __ctx?: {
            attrs?: any;
            slots?: K extends {
                $slots: infer Slots;
            } ? Slots : any;
            emit?: K extends {
                $emit: infer Emit;
            } ? Emit : any;
        } & {
            props?: (K extends {
                $props: infer Props;
            } ? Props : any) & Record<string, unknown>;
            expose?(exposed: K): void;
        };
    } : T extends () => any ? (props: {}, ctx?: any) => ReturnType<T> : T extends (...args: any) => any ? T : (_: {} & Record<string, unknown>, ctx?: any) => {
        __ctx?: {
            attrs?: any;
            expose?: any;
            slots?: any;
            emit?: any;
            props?: {} & Record<string, unknown>;
        };
    };
    function __VLS_asFunctionalElement<T>(tag: T, endTag?: T): (_: T & Record<string, unknown>) => void;
    function __VLS_functionalComponentArgsRest<T extends (...args: any) => any>(t: T): 2 extends Parameters<T>['length'] ? [any] : [];
    function __VLS_normalizeSlot<S>(s: S): S extends () => infer R ? (props: {}) => R : S;
    function __VLS_tryAsConstant<const T>(t: T): T;
}
